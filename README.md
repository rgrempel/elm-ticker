# elm-ticker

This module provides an alternative implementation of the idea of a `Tick`
as used in [evancz/elm-effects](http://package.elm-lang.org/packages/evancz/elm-effects/latest).
That is, it offers on-demand ticks, which components can request independently.
This is an alternative to using a central clock via `Time.fps` or `Time.fpsWhen` or
[elm-animation-frame](http://package.elm-lang.org/packages/jwmerrill/elm-animation-frame/latest).

## Comparison with elm-effects

If you're using version 2.0 or later of
[evancz/elm-effects](http://package.elm-lang.org/packages/evancz/elm-effects/latest),
then you already have the equivalent of the significant optimization described
below. Thus, the only reason to use this module would be if you have your own
reasons for not wanting to use elm-effects.

To put it another way, this module is a kind of experiment. It tries to answer
this question: how could we do some of the smart things that elm-effects does
without an `Effects` type? For examples of what it looks like if you don't have
an `Effects` type, take a look at this modified version of the
[Elm architecture tutorial](https://github.com/rgrempel/elm-architecture-tutorial).

If none of that makes any sense to you, then you don't need this module.

## General operation

* The ticks generated by this module will fire according to the browser's
  native `requestAnimationFrame()` method -- that is, they will fire when the
  browser needs a new frame.

* Multiple requests for a tick will be consolidated until the tick fires,
  so that `requestAnimationFrame()` is only called once per tick. When the tick
  fires, all the conslidated requests will be fulfilled.

* Once your tick fires, if you need another one (e.g. your animation is not
  finished), then you need to request another one -- they don't continue to
  flow automatically.

* You can use `dropWhileWaiting` to 'debounce' your `Signal` of models so that your
  `view` is only recalculated once per animation frame. This turns out to be a
  very significant optimization, especially where your app has many components
  which are mananging their own animations.
  To see how much difference it makes, compare spinning 100 squares
  [without using dropWhileWaiting](https://rgrempel.github.io/elm-ticker/unoptimized.html)
  vs. the otherwise-identical code [using dropWhileWaiting](https://rgrempel.github.io/elm-ticker/optimized.html).
  
Note that this module provides a `Signal` of tasks which need to be executed. In
order for that to happen, you will need to connect that signal to a port in
your main module. For instance:

```elm
port tickerTasks : Signal (Task () ())
port tickerTasks =
    Ticker.tasks
```

Also note that the tasks returned by `tick` and `tock` are *not* automatically
sent through this `Signal` -- you will need to arrange for those tasks to be
executed in same way that other tasks are executed in your app.

## Functions

<h3>
tick : (Time -> Task x a) -> Task () ()
</h3>

Returns a task which, when executed, waits for the browser to request an
animation frame (via the browser's native requestAnimationFrame() method). It
then calls the function you provided, passing along the Time provided by 
requestAnimationFrame(). The Task returned by your function is then immediately
executed.

<h3>
tock : Address action -> (Time -> action) -> Task () ()
</h3>

Like tick, except that you provide a function which returns an action, which
will be sent to the address you provide, when the next frame is needed. Typically,
the 'function' you provide will be an action tag, for an action like:

```elm
type Action =
    Tick Time |
    ... other actions
```

Then, assuming you have an `address` which accepts such actions, you could call:

```elm
tock address Tick
```

... which will return a Task that, when executed, will wait until an animation
frame is needed and then send the message to the address.

<h3>
tasks : Signal (Task () ())
</h3>

A signal of tasks which the module needs to be executed in order to maintain
its internal state. In order to use this module, you need to connect this
signal to a port in your main module -- see example above.

<h3>
dropWhileWaiting : a -> Signal a -> Signal a
</h3>

Given a `Signal`, and an initial value, returns a new `Signal` which will
drop all updates while we are waiting for a tick. When the tick arrives, and
all the requests for a tick have been fulfilled, the `Signal` will emit its
current value.

This is useful to prevent your `view` logic from running while we are waiting
for a tick. There's no point updating the view multiple times before the next
animation frame is needed, after all! So, if you have an app structure like this:

```elm
models : Signal Model

initialModel : Model

view : Model -> Html

port main : Signal Html
port main = Signal.map view models
```

... then you can create some efficiency by changing the last line to this:

```elm
port main = Signal.map view (dropWhileWaiting initialModel models)
```

Of course, your app may be wired differently -- the main thing is to apply
`dropWhileWaiting` just before your 'view' logic is applied. Do be careful not
to prevent other parts of your logic from running -- you still need every
`update`, for instance.

Note that the initial value which you supply as the first parameter is not
actually used -- it would only be used if the initial state would be to drop
updates, which it is not. However, the initial value is still required in
order to satisfy the type checker -- it can be anything that has the
correct type.

## Installation

Because elm-ticker uses a 'native' module, it
[requires approval](https://github.com/elm-lang/package.elm-lang.org/issues/71)
before it can be included in the
[Elm package repository](http://package.elm-lang.org/packages). Thus, you cannot
currently install it using `elm-package`.

In fact, it is unlikely that elm-ticker will get approval to appear in the
Elm package repository. This is essentially for two reasons:

*   elm-ticker is, admittedly, an experimental module -- an alternative to
    mainstream Elm best practices. Therefore, its appearance in the Elm package
    repository could be a distraction to the development of the Elm community.

*   It is possible that Elm may, in the future, wish to treat `requestAnimationFrame`
    in a special way -- for instance, in order to 'play nice' with elm-reactor.
    It will be easier to do that if the use of `requestAnimationFrame` is centralized
    in a smaller number of modules.

However, if you insist on installing elm-ticker, it can be done via the following steps:

*   Download this respository in one way or another. For instance, you might use:

        git clone https://github.com/rgrempel/elm-ticker.git

    Or, you might use git submodules, if you're adept at that. (I wouldn't suggest
    trying it if you've never heard of them before).

*   Modify your `elm-package.json` to refer to the `src` folder.

    You can choose where you want to put the downloaded code, but wherever that
    is, simply modify your `elm-package.json` file so that it can find the
    `src` folder.  So, the "source-directories" entry in your
    `elm-package.json` file might end up looking like this:

        "source-directories": [
            "src",
            "elm-ticker/src"
        ],

    But, of course, that depends on where you've actually put it.

*   Modify your `elm-package.json` to indicate that you're using 'native' modules.
    To do this, add the following entry to `elm-package.json`:

        "native-modules": true,

Now, doing this would have several implications which you should be aware of.

*   You would, essentially, be trusting me (or looking to verify for yourself)
    that the code in [Ticker.js](src/Native/Ticker.js) is appropriate code for
    a 'native' module.

*   You would be relying on me to update that code when the mechanism for using
    'native' modules in Elm changes, or when certain other internal details of Elm's
    implementation change. Furthermore, you'd have to check here whenever the Elm
    compiler's version changes, or the Elm core library's version changes, to see
    whether an update is required.

*   If you're using this as part of a module you'd like to publish yourself,
    then you won't be able to publish your module in the Elm package repository
    either.

So, you may or may not really want to do this. But I thought it would be nice to
let you know how.
