module Ticker (tick, tock, tasks, dropWhileWaiting) where
{-| This module offers on-demand ticks, as an alternative to using `Time.fps`
or `Time.fpsWhen` to manage a `Signal` that produces ticks, or using `Task.sleep`
to delay a task, or using 
[elm-animation-frame](http://package.elm-lang.org/packages/jwmerrill/elm-animation-frame/latest)
for a `Signal` of animtation frames.

* The ticks generated by this module will fire according to the browser's
  native `requestAnimationFrame()` method -- that is, they will fire when the
  browser needs a new frame.

* Multiple requests for a tick will be consolidated until the tick fires,
  so that `requestAnimationFrame()` is only called once per tick. When the tick
  fires, all the conslidated requests will be fulfilled.

* Once your tick fires, if you need another one (e.g. your animation is not
  finished), then you need to request another one -- they don't continue to
  flow automatically.

* You can use `dropWhileWaiting` to 'debounce' your `Signal` of models so that your
  `view` method is only recalculated once per animation frame. This turns out to be
  a very significant optimization, especially where your app has many components
  which are mananging their own animations. To see how much difference it makes,
  compare spinning 100 squares
  [without using dropWhileWaiting](https://rgrempel.github.io/elm-ticker/unoptimized.html)
  vs. the otherwise-identical code [using dropWhileWaiting](https://rgrempel.github.io/elm-ticker/optimized.html).

Note that this module provides a signal of tasks which need to be executed. In
order for that to happen, you will need to connect that signal to a port in
your main module. For instance:

    port tickerTasks : Signal (Task () ())
    port tickerTasks =
        Ticker.tasks

Also note that the tasks returned by `tick` and `tock` are *not* automatically
sent through this Signal -- you will need to arrange for those tasks to be
executed in same way that other tasks are executed in your app.

@docs tick, tock, tasks, dropWhileWaiting

-}

import Task exposing (Task, andThen)
import Time exposing (Time)
import Signal exposing (Address, Mailbox, send, mailbox, foldp)
import Native.Ticker


----------------
-- Public API --
----------------

{-| Returns a task which, when excecuted, waits for the browser to request an
animation frame (via the browser's native requestAnimationFrame() method). It
then calls the function you provided, passing along the Time provided by 
requestAnimationFrame(). The Task returned by your function is then immediately
executed.
-}
tick : (Time -> Task x a) -> Task () ()
tick func =
    send actions.address <|
        Request (converge func)


{-| Like tick, except that you provide a function which returns an action, which
will be sent to the address you provide, when the next frame is needed. Typically,
the 'function' you provide will be an action tag, for an action like:

    type Action =
        Tick Time |
        ... other actions

Then, assuming you have an `address` which accepts such actions, you could call:

    tock address Tick

... which will return a Task that, when executed, will wait until an animation
frame is needed and then send the message to the address.
-}
tock : Address action -> (Time -> action) -> Task () ()
tock address func =
    tick <|
        send address << func


-- Note that there's really no way to avoid forcing the user of the library to
-- connect the signal to a port ... it's a consequence of Elm's rule that only
-- the main module can create ports.

{-| A signal of tasks which the module needs to be executed in order to maintain
its internal state. In order to use this module, you need to connect this
signal to a port in your main module -- see example above.
-}
tasks : Signal (Task () ())
tasks =
    Signal.filterMap snd (Task.succeed ()) steps


{-| Given a `Signal`, and an initial value, returns a new `Signal` which will
drop all updates while we are waiting for a tick. When the tick arrives, and
all the requests for a tick have been fulfilled, the `Signal` will emit its
current value.

This is useful to prevent your 'view' logic from running while we are waiting
for a tick. There's no point updating the view multiple times before the next
animation frame is needed, after all! So, if you have an app structure like this:

    models : Signal Model

    initialModel : Model

    view : Model -> Html

    port main : Signal Html
    port main = Signal.map view models

... then you can create some efficiency by changing the last line to this:

    port main = Signal.map view (dropWhileWaiting initialModel models)

Of course, your app may be wired differently -- the main thing is to apply
`dropWhileWaiting` just before your 'view' logic is applied. Do be careful not
to prevent other parts of your logic from running -- you still need every
`update`, for instance.

Note that the initial value which you supply as the second parameter is not
actually used -- it would only be used if the initial state would be to drop
updates, which it is not. However, for the initial value is still required in
order to satisfy the type checker -- it can be anything that has the
correct type.
-}
dropWhileWaiting : a -> Signal a -> Signal a
dropWhileWaiting base models =
    let
        -- This one will update whenever *either* side updates ... that is,
        -- whenever we have a new model *or* we change our waiting state.
        zipped =
            Signal.map2 (,) models waiting.signal
        
        -- This will keep the zipped tuple so long as we're not waiting ...
        -- note that base is never really used, because waiting starts
        -- out False and the `not` makes it True, so we keep the first.
        filtered =
            Signal.filter (not << snd) (base, False) zipped 

    in
        -- And then we just extract the first thing from the filtered tuple.
        -- Note that a value can be repeated if our waiting signal flashes
        -- True and then False again with no intervening value having arrived
        -- on the input signal. However, that wouldn't be the usual pattern.
        -- We only wait if someone wants a tick, and they'll update the model
        -- based on it, so in the usual scenario a new model will have arrived.
        Signal.map fst filtered


--------------------
-- Implementation -- 
--------------------

{- Tracks our status, to support dropWhileWaiting.
-}
waiting : Mailbox Bool
waiting = mailbox False


{- The signature for `tick` calls for a function that produces a `Task x a` 
because we don't actually care what the task does. However, internally we need
to put the functions in a list. To put them in the same list, the x's and a's
would need to converge -- that is, you can't have a List of Tasks unless you
converge the x's and a's. So, we have to force them to converge. At least, I
think this is the explanation for the type errors I was getting when I tried
the `Task x a` approach without forcing convergence.
-}

converge : (Time -> Task x a) -> (Time -> Task () ()) 
converge func =
    Task.map (always ()) <<
        Task.mapError (always ()) <<
            func


-- Make types less verbose
type alias HandledTask = Task () ()
type alias Func = (Time -> HandledTask)


type Action
    = Request Func
    | Execute Time


actions : Mailbox Action
actions =
    mailbox (Execute 0)


steps : Signal (List Func, Maybe HandledTask)
steps =
    foldp step ([], Nothing) actions.signal


step : Action -> (List Func, Maybe HandledTask) -> (List Func, Maybe HandledTask)
step action (list, task) =
    case action of
        Request func ->
            if List.isEmpty list
                then ([func], Just schedule)
                else (func :: list, Nothing)

        Execute time ->
            ( []
            , Just <|
                batch (List.map ((|>) time) list)
                `andThen` always (Signal.send waiting.address False)
            )


batch : List (Task x a) -> HandledTask
batch tasks =
    Task.map (always ()) <|
        Task.mapError (always ()) <|
            Task.sequence tasks


schedule : HandledTask
schedule =
    let
        raf =
            requestAnimationFrame <|
                Signal.send actions.address << Execute
    
    in
        Signal.send waiting.address True
            `andThen` always raf


requestAnimationFrame : (Time -> HandledTask) -> HandledTask
requestAnimationFrame =
    Native.Ticker.requestAnimationFrame

